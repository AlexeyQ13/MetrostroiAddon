--------------------------------------------------------------------------------
-- Simulation acceleration DLL support
--------------------------------------------------------------------------------
if Turbostroi and not Turbostroi.SetMTAffinityMask then return end
local turbostroiTrains = {}
if not TURBOSTROI then
    local FPS = 33
    local messageTimeout = 0
    local messageCounter = 0
    local dataCache = {{},{}}
    hook.Add("EntityRemoved","Turbostroi",function(ent)
        if dataCache[ent] then
            dataCache[ent] = nil
        end
        if turbostroiTrains[ent] then
            turbostroiTrains[ent] = nil
        end
    end)
    for k,ent in pairs(ents.GetAll()) do
        if ent.Base == "gmod_subway_base" and not ent.NoTrain and not ent.DontAccelerateSimulation then
            turbostroiTrains[ent] = true
        end
    end
    hook.Add("OnEntityCreated","Turbostroi",function(ent)
        timer.Simple(0,function()
            if IsValid(ent) and ent.Base == "gmod_subway_base" and not ent.NoTrain and not ent.DontAccelerateSimulation then
                turbostroiTrains[ent] = true
            end
        end)
    end)
    local inputCache = {}
    local id,system,name,index,value
    local _DEBUGPRINT
    local function updateTrains(trains)
        --local recvMessage = Turbostroi.RecvMessage
        -- Get data packets from simulation
        for train in pairs(trains) do
            if not dataCache[train] then
                if not Turbostroi.SendMessage(train,5,"","",0,0) then return end
                dataCache[train] = {wiresW = {}}

                for sys_name,system in pairs(train.Systems) do
                    if system.OutputsList and system.DontAccelerateSimulation then
                        for _,name in pairs(system.OutputsList) do
                            local value = system[name] or 0
                            if type(value) == "boolean" then value = value and 1 or 0 end
                            if type(value) == "number" then
                                if not dataCache[train][sys_name] then dataCache[train][sys_name] = {} end
                                dataCache[train][sys_name][name] = math.Round(value)
                            end
                        end
                    end
                end
            end
            for i,message in pairs(Turbostroi.RecvMessages(train)) do --NEWTURBOSTROI
                id,system,name,index,value = unpack(message,0) --NEWTURBOSTROI
            --while true do --OLDTURBOSTROI
                --id,system,name,index,value = Turbostroi.RecvMessage(train)
                if id == 1 then
                    if train.Systems[system] then
                        train.Systems[system][name] = value
                        if train.TriggerTurbostroiInput then train:TriggerTurbostroiInput(system,name,value) end
                    end
                end
                if id == 2 then
                    if index == 0 and name ~= "bass" then index = nil end
                    if value == 0 and name ~= "bass" then value = nil end
                    if name == "" then name = nil end
                        --net.WriteString(name)
                    train:PlayOnce(system,name,index,value)
                end
                if id == 3 then
                    if name == "on" then
                        --print("[!]Wire "..index.." starts update! Value "..value)
                        dataCache[train]["wiresW"][index] = value
                        --train:WriteTrainWire(index,value)
                        if not train.TrainWireWritersID[index] then train.TrainWireWritersID[index] = true end
                        train.TrainWireTurbostroi[index] = value
                        if train.TriggerTurbostroiInput then train:TriggerTurbostroiInput("TrainWire",index,value) end
                    else
                        --print("[!]Wire "..index.." stop update!")
                        dataCache[train]["wiresW"][index] = nil
                    end
                end
                if id == 4 then
                    if train.Systems[system] then
                        train.Systems[system]:TriggerInput(name,value)
                    end
                end
                if id == 5 then
                    for twid,value in pairs(dataCache[train]["wiresW"]) do
                        --train:WriteTrainWire(twid,value)
                    end
                end
                if id == 6 then
                    if IsValid(Player(index)) then
                        if value==0 then
                            Player(index):PrintMessage( HUD_PRINTCONSOLE, "--START" )
                            print("--START")
                        end
                        Player(index):PrintMessage( HUD_PRINTCONSOLE, system )
                        print(system)
                    end
                end
                --print(id,name)

                --if not id then
                    --break--OLDTURBOSTROI
                --end
                messageCounter = messageCounter + 1
            end
        end
        -- Send train wire values
        -- Output all system values
        for train in pairs(trains) do
            if train.ReadTrainWire then
                for i in pairs(train.TrainWires) do
                    if not dataCache[train]["wires"] then dataCache[train]["wires"] = {} end
                    if dataCache[train]["wires"][i] ~= train:ReadTrainWire(i) then
                        if Turbostroi.SendMessage(train,3,"","",i,train:ReadTrainWire(i)) then
                            dataCache[train]["wires"][i] = train:ReadTrainWire(i)
                        end
                    end
                end
                for sys_name,system in pairs(train.Systems) do
                    if system.OutputsList and system.DontAccelerateSimulation then
                        for _,name in pairs(system.OutputsList) do
                            local value = system[name] or 0
                            if type(value) == "boolean" then
                                value = value and 1 or 0
                            end
                            if type(value) == "number" then
                                value = math.Round(value)
                                if not dataCache[train][sys_name] then dataCache[train][sys_name] = {} end
                                if dataCache[train][sys_name][name] ~= value then
                                    if Turbostroi.SendMessage(train,1,sys_name,name,0,value) then
                                        dataCache[train][sys_name][name] = value
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if Turbostroi then
        concommand.Add("metrostroi_turbostroi_run",function(ply,_,_,cmd)
            if not IsValid(ply) then return end
            local train = ply:GetTrain()
            if IsValid(train) then
                print(cmd:sub(1,2),cmd:sub(3,4))
                Turbostroi.SendMessage(train,6,cmd:sub(1,255),cmd:sub(256,511),ply:UserID(),0)
            end
        end)
        function Turbostroi.TriggerInput(train,system,name,value)
            local v = value or 0
            if type(value) == "boolean" then v = value and 1 or 0 end
                Turbostroi.SendMessage(train,4,system,name,0,v)
            --end
        end
        Turbostroi.SetMTAffinityMask(8) -- CPU5 CPU4 on 6 core --NEWTURBOSTROI
        Turbostroi.SetSTAffinityMask(7) -- 0 - disabled --NEWTURBOSTROI
        Turbostroi.SetSimulationFPS(FPS)
        hook.Add("Think", "Turbostroi_Think", function()
            if not Turbostroi then return end

            -- Proceed with the think loop
            --Turbostroi.SetTargetTime(CurTime()) //depricated! now using engine
            --Turbostroi.Think() //depricated! now using engine

            -- Update all types of trains
            --for k,v in ipairs(turbostroiTrains) do
                updateTrains(turbostroiTrains)
            --end
            -- HACK
            GLOBAL_SKIP_TRAIN_SYSTEMS = nil

            -- Print stats
                if ((CurTime() - messageTimeout) > 1.0) then
                messageTimeout = CurTime()
                --RunConsoleCommand("say",Format("Metrostroi: %d messages per second (%d per tick)",messageCounter,messageCounter / FPS))
                messageCounter = 0
            end
        end)
    end
    return
end




--------------------------------------------------------------------------------
-- Turbostroi scripts
--------------------------------------------------------------------------------
-- NEW API
local ffi = require("ffi")
local C = ffi.load("gmsv_turbostroi_win32")
ffi.cdef[[
bool ThreadSendMessage(void *p, int message, const char* system_name, const char* name, double index, double value);
]]

Metrostroi = {}
local dataCache = {wires = {},wiresW = {},wiresL = {}}
Metrostroi.BaseSystems = {} -- Systems that can be loaded
Metrostroi.Systems = {} -- Constructors for systems

LoadSystems = {} -- Systems that must be loaded/initialized
GlobalTrain = {} -- Train emulator
GlobalTrain.Systems = {} -- Train systems
GlobalTrain.TrainWires = {}
GlobalTrain.WriteTrainWires = {}

TimeMinus = 0
_Time = 0
function CurTime()
    --return CurrentTime-TimeMinus
    return _Time
end
--function CurTime() return os.clock() end

function Metrostroi.DefineSystem(name)
    TRAIN_SYSTEM = {}
    Metrostroi.BaseSystems[name] = TRAIN_SYSTEM

    -- Create constructor
    Metrostroi.Systems[name] = function(train,...)
        local tbl = { _base = name }
        local TRAIN_SYSTEM = Metrostroi.BaseSystems[tbl._base]
        if not TRAIN_SYSTEM then print("No system: "..tbl._base) return end
        for k,v in pairs(TRAIN_SYSTEM) do
            if type(v) == "function" then
                tbl[k] = function(...)
                    if not Metrostroi.BaseSystems[tbl._base][k] then
                        print("ERROR",k,tbl._base)
                    end
                    return Metrostroi.BaseSystems[tbl._base][k](...)
                end
            else
                tbl[k] = v
            end
        end

        tbl.Initialize = tbl.Initialize or function() end
        tbl.Think = tbl.Think or function() end
        tbl.Inputs = tbl.Inputs or function() return {} end
        tbl.Outputs = tbl.Outputs or function() return {} end
        tbl.TriggerInput = tbl.TriggerInput or function() end
        tbl.TriggerOutput = tbl.TriggerOutput or function() end

        tbl.Train = train
        tbl:Initialize(...)
        tbl.OutputsList = tbl:Outputs()
        tbl.InputsList = tbl:Inputs()
        tbl.IsInput = {}
        for k,v in pairs(tbl.InputsList) do tbl.IsInput[v] = true end
        return tbl
    end
end

function GlobalTrain.LoadSystem(self,a,b,...)
    local name
    local sys_name
    if b then
        name = b
        sys_name = a
    else
        name = a
        sys_name = a
    end

    if not Metrostroi.Systems[name] then error("No system defined: "..name) end
    if self.Systems[sys_name] then error("System already defined: "..sys_name)  end

    self[sys_name] = Metrostroi.Systems[name](self,...)
    self[sys_name].Name = sys_name
    self[sys_name].BaseName = name
    self.Systems[sys_name] = self[sys_name]

    -- Don't simulate on here
    local no_acceleration = Metrostroi.BaseSystems[name].DontAccelerateSimulation
    if no_acceleration then
        self.Systems[sys_name].Think = function() end
        self.Systems[sys_name].TriggerInput = function(train,name,value)
            local v = value or 0
            if type(value) == "boolean" then v = value and 1 or 0 end
            C.ThreadSendMessage(_userdata, 4,sys_name,name,0,v)
        end -- replace with new api

    --Precache values
    elseif self[sys_name].OutputsList then
        dataCache[sys_name] = {}
        for _,name in pairs(self[sys_name].OutputsList) do
            dataCache[sys_name][name] = 0--self[sys_name][name] or 0
        end
    end
end

function GlobalTrain.PlayOnce(self,soundid,location,range,pitch)
    C.ThreadSendMessage(_userdata, 2,soundid or "",location or "",range or 0,pitch or 0) -- replace with new api
end

function GlobalTrain.ReadTrainWire(self,n)
    return self.TrainWires[n] or 0
end

function GlobalTrain.WriteTrainWire(self,n,v)
    self.WriteTrainWires[n] = v
end


GlobalTrain.DeltaTime = 0.33

--------------------------------------------------------------------------------
-- Main train code (turbostroi side)
--------------------------------------------------------------------------------
print("[!] Train initialized!")
function Think(skipped)
    -- This is just blatant copy paste from init.lua of base train entity
    local self = GlobalTrain

    --[[ if skipped then
        self.BeSkip = self.BeSkip or CurTime()
        return
    else
        self.PrevTime = self.PrevTime or CurTime()
        if self.BeSkip then
            --print(1,(CurTime()-self.BeSkip)-0.03)
            TimeMinus = TimeMinus + math.max(0,(CurTime()-self.BeSkip)-0.03)
            --print(2,TimeMinus)
            self.BeSkip = false
        end
    end--]]

    -- Is initialized?
    if not self.Initialized then
        Initialize()
        return
    end

    self.DeltaTime = (CurrentTime - self.PrevTime)--self.DeltaTime+math.min(0.02,((CurrentTime - self.PrevTime)-self.DeltaTime)*0.1)
    self.PrevTime = CurrentTime
    if skipped or self.DeltaTime<=0 then return end
    _Time = _Time+self.DeltaTime

    -- Perform data exchange
    DataExchange()

    -- Simulate according to schedule
    for i,s in ipairs(self.Schedule) do
        for k,v in ipairs(s) do
            v:Think(self.DeltaTime / (v.SubIterations or 1),i)
        end
    end
end

function Initialize()
    if not CurrentTime then return end
    print("[!] Loading systems")
    local time = os.clock()
    for k,v in pairs(LoadSystems) do
        GlobalTrain:LoadSystem(k,v)
    end
    print(string.format("[!] -Took %.2fs",os.clock()-time))
    GlobalTrain.PrevTime = CurrentTime
    local iterationsCount = 1
    if (not GlobalTrain.Schedule) or (iterationsCount ~= GlobalTrain.Schedule.IterationsCount) then
        GlobalTrain.Schedule = { IterationsCount = iterationsCount }
        local SystemIterations = {}

        -- Find max number of iterations
        local maxIterations = 0
        for k,v in pairs(GlobalTrain.Systems) do
            SystemIterations[k] = (v.SubIterations or 1)
            maxIterations = math.max(maxIterations,(v.SubIterations or 1))
        end

        -- Create a schedule of simulation
        for iteration=1,maxIterations do
            GlobalTrain.Schedule[iteration] = {}
            -- Populate schedule
            for k,v in pairs(GlobalTrain.Systems) do
                if ((iteration)%(maxIterations/(v.SubIterations or 1))) == 0 then
                    table.insert(GlobalTrain.Schedule[iteration],v)
                end

            end
        end
    end
    GlobalTrain.Initialized = true
end

local id,system,name,index,value
function DataExchange()
    -- Get data packets
    for i,message in pairs(RecvMessages()) do
        id,system,name,index,value = unpack(message,0) --NEWTURBOSTROI
    --while true do
        --id,system,name,index,value = RecvMessage() --OLDTURBOSTROI
        if id == 1 then
            if GlobalTrain.Systems[system] then
                GlobalTrain.Systems[system][name] = value
            end
        end
        if id == 3 then
            dataCache["wiresW"][index] = value
        end
        if id == 4 then
            if GlobalTrain.Systems[system] then
                GlobalTrain.Systems[system]:TriggerInput(name,value)
            end
        end
        if id == 5 then
            dataCache["wiresL"] = {}
        end
        if id == 6 then
            local scr = [[
            local _retdata=""
            local print = function(...)
                for k,v in ipairs({...}) do _retdata = _retdata..tostring(v).."\t" end
                _retdata = _retdata.."\n"
            end
            ]]
            scr = scr..system..name.."\n"
            scr = scr.."return _retdata"
            local data,err = loadstring(scr)
            if data then
                local ret = tostring(data()) or "N\\A"
                for i=0,math.ceil(#ret/63) do
                    C.ThreadSendMessage(_userdata, 6, ret:sub(i*63,(i+1)*63-1), "",index,i)
                end
            else
                print(err)
                C.ThreadSendMessage(_userdata, 6, tostring(err), "",index,0)
            end
            --Turbostroi.SendMessage(train,6,cmd:sub(1,255),cmd:sub(256,511),ply:UserID(),0)
        end
        if not id then break end
    end
    for twid,value in pairs(dataCache["wiresW"]) do
        GlobalTrain.TrainWires[twid] = value
    end

    -- Output all variable values
    for sys_name,system in pairs(GlobalTrain.Systems) do
        if system.OutputsList and (not system.DontAccelerateSimulation) then
            for _,name in pairs(system.OutputsList) do
                local value = (system[name] or 0)
                --if type(value) == "boolean" then value = value and 1 or 0 end
                if not dataCache[sys_name] then print(sys_name) end
                if dataCache[sys_name][name] ~= value then
                    --print(sys_name,name,value)
                    --if SendMessage(1,sys_name,name,0,tonumber(value) or 0) then -- OLD API
                    if C.ThreadSendMessage(_userdata, 1, sys_name , name, 0, tonumber(value) or 0) then -- NEW API
                        dataCache[sys_name][name] = value
                    end
                end
            end
        end
    end

    -- Output train wire writes
    for twID,value in pairs(GlobalTrain.WriteTrainWires) do
        --local value = tonumber(value) or 0
        if dataCache["wires"][twID] ~= value then
            dataCache["wires"][twID] = value
            dataCache["wiresL"][twID] = false
        end
        if not dataCache["wiresL"][twID] or dataCache["wiresL"][twID]~=GlobalTrain.PrevTime then
            --SendMessage(3,"","on",tonumber(twID) or 0,dataCache["wires"][twID]) -- OLD API
            C.ThreadSendMessage(_userdata, 3, "", "on", tonumber(twID) or 0, dataCache["wires"][twID]) -- NEW API
            --print("[!]Wire "..twID.." starts update! Value "..dataCache["wires"][twID])
        end
        GlobalTrain.WriteTrainWires[twID] = nil
        dataCache["wiresL"][twID] = CurTime()
    end
    for twID,time in pairs(dataCache["wiresL"]) do
        if time~=CurTime() then
            C.ThreadSendMessage(_userdata,3, "", "off", tonumber(twID) or 0, 0)
            --print("[!]Wire "..twID.." stops update!")
            dataCache["wiresL"][twID] = nil
        end
    end
    --SendMessage(5,"","",0,0) -- OLD API
    --C.ThreadSendMessage(_userdata, 5,"","",0,0) -- NEW API
    --print(string.format("%s %s",count,#msgCache))
    --count = 0

end
